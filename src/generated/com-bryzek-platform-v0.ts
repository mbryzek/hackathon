/**
 * TypeScript types for platform
 * Based on API Builder specification at com.bryzek.platform.v0
 *
 * Generated by API Builder - do not edit manually
 */

import type { ISODateTimeString } from './generated-types';

// ============================================================================
// Enums
// ============================================================================

export enum Consent {
  OptedIn = 'opted_in',
  OptedOut = 'opted_out',
  Pending = 'pending',
}

export enum Environment {
  Production = 'production',
  Sandbox = 'sandbox',
}

export enum Gender {
  Male = 'male',
  Female = 'female',
  Other = 'other',
}

export enum TimeZone {
  AmericaNewYork = 'america_new_york',
  AmericaChicago = 'america_chicago',
  AmericaDenver = 'america_denver',
  AmericaLosAngeles = 'america_los_angeles',
  AmericaPhoenix = 'america_phoenix',
  AmericaAnchorage = 'america_anchorage',
  PacificHonolulu = 'pacific_honolulu',
  AmericaHalifax = 'america_halifax',
  AmericaStJohns = 'america_st_johns',
  AmericaMexicoCity = 'america_mexico_city',
  AmericaCancun = 'america_cancun',
  EuropeLondon = 'europe_london',
  EuropeParis = 'europe_paris',
  EuropeHelsinki = 'europe_helsinki',
  EuropeMoscow = 'europe_moscow',
  EuropeIstanbul = 'europe_istanbul',
  AsiaTokyo = 'asia_tokyo',
  AsiaSeoul = 'asia_seoul',
  AsiaShanghai = 'asia_shanghai',
  AsiaHongKong = 'asia_hong_kong',
  AsiaSingapore = 'asia_singapore',
  AsiaBangkok = 'asia_bangkok',
  AsiaJakarta = 'asia_jakarta',
  AsiaManila = 'asia_manila',
  AsiaKualaLumpur = 'asia_kuala_lumpur',
  AsiaKolkata = 'asia_kolkata',
  AsiaKarachi = 'asia_karachi',
  AsiaDubai = 'asia_dubai',
  AsiaTehran = 'asia_tehran',
  AustraliaSydney = 'australia_sydney',
  AustraliaBrisbane = 'australia_brisbane',
  AustraliaPerth = 'australia_perth',
  AustraliaAdelaide = 'australia_adelaide',
  AustraliaDarwin = 'australia_darwin',
  PacificAuckland = 'pacific_auckland',
  PacificFiji = 'pacific_fiji',
  AmericaSaoPaulo = 'america_sao_paulo',
  AmericaArgentinaBuenosAires = 'america_argentina_buenos_aires',
  AmericaSantiago = 'america_santiago',
  AmericaLima = 'america_lima',
  AmericaBogota = 'america_bogota',
  AmericaCaracas = 'america_caracas',
  AfricaCairo = 'africa_cairo',
  AfricaLagos = 'africa_lagos',
  AfricaJohannesburg = 'africa_johannesburg',
  AfricaNairobi = 'africa_nairobi',
  AfricaCasablanca = 'africa_casablanca',
  Utc = 'utc',
}

export enum UserRole {
  Admin = 'admin',
  User = 'user',
}

export enum UserStatus {
  Pending = 'pending',
  Active = 'active',
  Inactive = 'inactive',
}

// ============================================================================
// Models
// ============================================================================

export interface BirthInfo {
  month: number;
  year: number;
}

export interface BirthInfoForm {
  month: number;
  year: number;
}

export interface Email {
  id: string;
  address: string;
  verified_at?: ISODateTimeString;
}

export interface EmailVerification {

}

export interface LoginForm {
  email: string;
  password: string;
}

export interface MobilePhoneForm {
  number: string;
  optin_to_sms?: boolean;
  allowed_to_share?: boolean;
}

export interface Money {
  amount: number;
  currency: string;
}

export interface PasswordChangeForm {
  id: string;
  password: string;
}

export interface PasswordResetForm {
  email: string;
}

export interface Phone {
  id: string;
  number: string;
  consent: Consent;
}

export interface PrivateDinkersUserData {
  dupr: number;
}

export interface PrivateDinkersUserDataForm {
  dupr: number;
}

export interface SessionReference {
  id: string;
}

export interface SignupForm {
  user: UserForm;
  password: string;
}

export interface TenantReference {
  id: string;
}

export interface TenantSession {
  discriminator: 'tenant_session';
  session: SessionReference;
  user: User;
}

export interface User {
  id: string;
  tenant: TenantReference;
  email: Email;
  /** Full name */
  name?: string;
  /** What to call the user */
  nickname?: string;
  birth?: BirthInfo;
  gender?: Gender;
  status: UserStatus;
  role: UserRole;
  mobile_phone?: Phone;
  time_zone: TimeZone;
  private_dinkers?: PrivateDinkersUserData;
}

export interface UserForm {
  email: string;
  /** Full name */
  name?: string;
  /** What to call the user */
  nickname?: string;
  birth?: BirthInfoForm;
  gender?: Gender;
  mobile_phone?: MobilePhoneForm;
  time_zone?: TimeZone;
  private_dinkers?: PrivateDinkersUserDataForm;
}

export interface UserInactive {
  discriminator: 'user_inactive';
  status: UserStatus;
}

export interface UserPasswordForm {
  current_password: string;
  new_password: string;
}

export interface UserPasswordSuggestion {
  password: string;
}

export interface UserReference {
  id: string;
}

export interface UserSecondaryForm {
  birth?: BirthInfoForm;
  gender?: Gender;
  time_zone?: TimeZone;
  private_dinkers?: PrivateDinkersUserDataForm;
}

// ============================================================================
// Union Types
// ============================================================================

export type SessionState = TenantSession | UserInactive;

export const SessionStateDiscriminator = {
  TenantSession: 'tenant_session',
  UserInactive: 'user_inactive'
} as const;

export function isTenantSession(obj: SessionState): obj is TenantSession {
  return obj.discriminator === 'tenant_session';
}

export function isUserInactive(obj: SessionState): obj is UserInactive {
  return obj.discriminator === 'user_inactive';
}

// ============================================================================
// API Client
// ============================================================================

import { VoidResponse } from './generated-error-void-response.ts';
import { UnauthorizedErrorsResponse } from './generated-error-unauthorized-errors-response.ts';
import { ValidationErrorsResponse } from './generated-error-validation-errors-response.ts';
import { ApiException } from "./generated-util.ts";

export interface UpdateEmailVerificationByTokenOptions {
  headers?: Record<string, string>;
}

export interface CreatePhoneOptinAndRequestByIdOptions {
  headers?: Record<string, string>;
}

export interface GetTenantSessionOptions {
  headers?: Record<string, string>;
}

export interface CreateTenantSessionLoginsOptions {
  tenantId: string;
  body: LoginForm;
  headers?: Record<string, string>;
}

export interface CreateTenantSessionSignupsOptions {
  tenantId: string;
  body: SignupForm;
  headers?: Record<string, string>;
}

export interface CreateTenantSessionPasswordAndChangesOptions {
  tenantId: string;
  body: PasswordChangeForm;
  headers?: Record<string, string>;
}

export interface CreateTenantSessionPasswordAndResetsOptions {
  tenantId: string;
  body: PasswordResetForm;
  headers?: Record<string, string>;
}

export interface DeleteTenantSessionOptions {
  headers?: Record<string, string>;
}

export interface GetUsersOptions {
  limit: number;
  offset: number;
  id?: string[];
  q?: string;
  tenantId?: string;
  status?: UserStatus[];
  role?: UserRole[];
  sort?: string;
  headers?: Record<string, string>;
}

export interface GetUserByIdOptions {
  headers?: Record<string, string>;
}

export interface CreateUserTenantByTenantIdOptions {
  tenantId: string;
  body: UserForm;
  headers?: Record<string, string>;
}

export interface UpdateUserByIdOptions {
  id: string;
  body: UserForm;
  headers?: Record<string, string>;
}

export interface UpdateUserSecondaryByIdOptions {
  id: string;
  body: UserSecondaryForm;
  headers?: Record<string, string>;
}

export interface UpdateUserPasswordByIdOptions {
  id: string;
  body: UserPasswordForm;
  headers?: Record<string, string>;
}

export interface CreateUserPasswordAndSuggestionsOptions {
  headers?: Record<string, string>;
}

export interface CreateUserEmailAndVerificationsByIdOptions {
  headers?: Record<string, string>;
}

export class ApiClient {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  async updateEmailVerificationByToken(token: string, options?: UpdateEmailVerificationByTokenOptions): Promise<void> {
    const url = `${this.baseUrl}/email/verifications/${token}`;

      const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(options?.headers || {}),
      },
    });

    if (response.status === 204) {
      return;
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createPhoneOptinAndRequestById(id: string, options?: CreatePhoneOptinAndRequestByIdOptions): Promise<void> {
    const url = `${this.baseUrl}/phones/${id}/optin/request`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(options?.headers || {}),
      },
    });

    if (response.status === 204) {
      return;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async getTenantSession(tenantId: string, options?: GetTenantSessionOptions): Promise<TenantSession> {
    const url = `${this.baseUrl}/tenant/${tenantId}/session`;

      const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...(options?.headers || {}),
      },
    });

    if (response.status === 200) {
      const data = await response.json();
      return data;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createTenantSessionLogins(params: CreateTenantSessionLoginsOptions): Promise<SessionState> {
    const url = `${this.baseUrl}/tenant/${params.tenantId}/session/logins`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 201) {
      const data = await response.json();
      return data;
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createTenantSessionSignups(params: CreateTenantSessionSignupsOptions): Promise<SessionState> {
    const url = `${this.baseUrl}/tenant/${params.tenantId}/session/signups`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 201) {
      const data = await response.json();
      return data;
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createTenantSessionPasswordAndChanges(params: CreateTenantSessionPasswordAndChangesOptions): Promise<SessionState> {
    const url = `${this.baseUrl}/tenant/${params.tenantId}/session/password/changes`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 201) {
      const data = await response.json();
      return data;
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createTenantSessionPasswordAndResets(params: CreateTenantSessionPasswordAndResetsOptions): Promise<void> {
    const url = `${this.baseUrl}/tenant/${params.tenantId}/session/password/resets`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 204) {
      return;
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async deleteTenantSession(tenantId: string, options?: DeleteTenantSessionOptions): Promise<void> {
    const url = `${this.baseUrl}/tenant/${tenantId}/session`;

      const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        ...(options?.headers || {}),
      },
    });

    if (response.status === 204) {
      return;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async getUsers(params: GetUsersOptions): Promise<User[]> {
    const queryParts: string[] = [];
    if (params.id !== undefined && params.id !== null) {
      params.id.forEach(value => queryParts.push(`id=${encodeURIComponent(value)}`));
    }
    if (params.q !== undefined && params.q !== null) {
      queryParts.push(`q=${encodeURIComponent(params.q)}`);
    }
    if (params.tenantId !== undefined && params.tenantId !== null) {
      queryParts.push(`tenant_id=${encodeURIComponent(params.tenantId)}`);
    }
    if (params.status !== undefined && params.status !== null) {
      params.status.forEach(value => queryParts.push(`status=${encodeURIComponent(String(value))}`));
    }
    if (params.role !== undefined && params.role !== null) {
      params.role.forEach(value => queryParts.push(`role=${encodeURIComponent(String(value))}`));
    }
    queryParts.push(`limit=${encodeURIComponent(String(params.limit))}`);
    queryParts.push(`offset=${encodeURIComponent(String(params.offset))}`);
    if (params.sort !== undefined && params.sort !== null) {
      queryParts.push(`sort=${encodeURIComponent(params.sort)}`);
    }
    const queryString = queryParts.length > 0 ? '?' + queryParts.join('&') : '';
    const url = `${this.baseUrl}/users${queryString}`;

      const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
    });

    if (response.status === 200) {
      const data = await response.json();
      return data;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async getUserById(id: string, options?: GetUserByIdOptions): Promise<User> {
    const url = `${this.baseUrl}/users/${id}`;

      const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...(options?.headers || {}),
      },
    });

    if (response.status === 200) {
      const data = await response.json();
      return data;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createUserTenantByTenantId(params: CreateUserTenantByTenantIdOptions): Promise<User> {
    const url = `${this.baseUrl}/users/tenant/${params.tenantId}`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 201) {
      const data = await response.json();
      return data;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async updateUserById(params: UpdateUserByIdOptions): Promise<User> {
    const url = `${this.baseUrl}/users/${params.id}`;

      const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 200) {
      const data = await response.json();
      return data;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async updateUserSecondaryById(params: UpdateUserSecondaryByIdOptions): Promise<User> {
    const url = `${this.baseUrl}/users/${params.id}/secondary`;

      const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 200) {
      const data = await response.json();
      return data;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async updateUserPasswordById(params: UpdateUserPasswordByIdOptions): Promise<void> {
    const url = `${this.baseUrl}/users/${params.id}/password`;

      const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
      body: JSON.stringify(params.body),
    });

    if (response.status === 204) {
      return;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createUserPasswordAndSuggestions(params: CreateUserPasswordAndSuggestionsOptions): Promise<UserPasswordSuggestion> {
    const url = `${this.baseUrl}/users/password/suggestions`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(params.headers || {}),
      },
    });

    if (response.status === 201) {
      const data = await response.json();
      return data;
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

  async createUserEmailAndVerificationsById(id: string, options?: CreateUserEmailAndVerificationsByIdOptions): Promise<void> {
    const url = `${this.baseUrl}/users/${id}/email/verifications`;

      const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(options?.headers || {}),
      },
    });

    if (response.status === 204) {
      return;
    }

    if (response.status === 401) {
      throw new UnauthorizedErrorsResponse(response);
    }

    if (response.status === 404) {
      throw new VoidResponse(response);
    }

    if (response.status === 422) {
      throw new ValidationErrorsResponse(response);
    }

    throw new ApiException(response, `Request failed with status ${response.status}`);

  }

}